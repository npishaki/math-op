<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Matrix Visual Calculator</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
          onload="if(typeof renderMathInElement === 'function'){renderMathInElement(document.body, {delimiters:[{left:'$$', right:'$$', display:true}]});} else {console.error('KaTeX auto-render not loaded.')}"></script>
  <style>
    body { background: #181c23; color: #f6f8fa; font-family: sans-serif; margin:0; padding-bottom: 80px; /* Space for test log */ }
    .demo-container { max-width: 900px; margin: 2em auto; background: #23272f; border-radius: 16px; box-shadow: 0 0 28px #1117; padding: 1.6em; }
    .matrix-flex { display: flex; gap: 1.5em; justify-content: center; align-items: flex-start; flex-wrap: wrap;}
    .matrix-label { text-align: center; font-weight: bold; margin-bottom: 0.4em; font-size: 1.1em; }
    .matrix-table { margin: 0 auto; border-collapse: collapse; position: relative; }
    .matrix-table td { width: 2.8em; height: 2.8em; font-size: 1.1em; text-align: center; border: 2px solid #555; background: #23272f; border-radius: 7px; color: #fff; cursor:pointer; transition: background 0.2s, color 0.2s; }
    .matrix-table td.selected { background: #4fa3ff; color: #23272f; font-weight: bold; } /* Pivot for Laplace */
    .matrix-table td.minor { background: #ffe165; color: #23272f; } /* Minor cells for Laplace */
    .matrix-table td.mul-row { background: #6fd6ffcc; color: #23272f; } /* Row for multiplication */
    .matrix-table td.mul-col { background: #ff6c90cc; color: #23272f; } /* Column for multiplication */
    .matrix-table td.mul-cell { background: #f5e960; color: #23272f; font-weight: bold;} /* Result cell for multiplication */
    .matrix-table td.term-highlight { background: #ff965acc; color: #23272f; font-weight: bold; } /* Current terms being multiplied */
    .button { background: #333e52; color: #fff; padding: 0.4em 1.2em; border: none; border-radius: 6px; font-size: 1em; font-weight: 600; margin: 0 0.6em 0.7em 0; cursor: pointer; transition: background 0.2s; }
    .button:hover { background: #2196f3; }
    .button:disabled { background: #2a313f; color: #777; cursor: not-allowed; }
    .mode-toggle { margin-bottom: 1.5em; text-align: center; }
    .matrix-group { display: flex; flex-direction: column; align-items: center; }
    .operator-display { font-size: 2em; line-height: 3em; margin: 0 0.5em; }
    .matrix-controls { margin-bottom: 0.4em; text-align: center;}
    .matrix-controls select { background:#292e39; color:#ffe165; border:1px solid #333e52; border-radius:6px; font-size:1em; margin:0 0.4em; padding: 0.2em;}
    .fade-in { animation: fadein 0.5s; }
    @keyframes fadein { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    #skipAnimBtn { position:fixed; right:28px; bottom:20px; z-index:2222; display:none;}
    #runFeatureTestBtn {
      position:fixed;top:24px;right:32px;z-index:9999;background:#181c23;color:#ffe165;
      padding:0.6em 1.1em;border-radius:7px;font-size:1em;font-weight:700;box-shadow:0 2px 9px #000a;
      border:2px solid #ffe165;cursor:pointer;
    }
    .latex-output { margin-top: 1em; padding: 0.5em; background: #2a313f55; border-radius: 8px; min-height: 2em; word-wrap: break-word;}
    @media (max-width: 900px) {
      .matrix-flex { flex-direction: column; align-items: stretch; gap: 1em;}
      .demo-container { padding: 1em; margin: 1em; }
      #skipAnimBtn { right:10px; bottom:10px; padding: 0.3em 0.8em; }
      .operator-display { line-height: 1.5em; margin: 0.5em 0; }
      .matrix-table td {width: 2.2em; height: 2.2em; font-size:1em;}
    }
  </style>
</head>
<body>
<div class="demo-container">
  <h2>Matrix Visual Calculator</h2>
  <div class="mode-toggle">
    <button class="button" id="modeLaplaceBtn">Laplace Expansion (Determinant)</button>
    <button class="button" id="modeMultiplyBtn">Matrix Multiply</button>
  </div>
  <div class="matrix-flex">
    <div class="matrix-group">
      <div class="matrix-label">Matrix A</div>
      <div class="matrix-controls">
        Rows: <select id="aRows"></select> &nbsp; Columns: <select id="aCols"></select>
      </div>
      <table class="matrix-table" id="mainMatrixA"></table>
      <div style="text-align:center; margin-top:0.5em;"><button class="button" id="randomA">Randomize A</button></div>
    </div>

    <div id="operatorSymbol" class="operator-display" style="display:none;"></div>

    <div id="matrixBContainer" class="matrix-group" style="display:none;">
      <div class="matrix-label">Matrix B</div>
      <div class="matrix-controls">
        Rows: <select id="bRows" disabled></select> &nbsp; Columns: <select id="bCols"></select>
      </div>
      <table class="matrix-table" id="mainMatrixB"></table>
      <div style="text-align:center; margin-top:0.5em;"><button class="button" id="randomB">Randomize B</button></div>
    </div>

    <div id="equalsSymbol" class="operator-display" style="display:none;">=</div>

    <div id="matrixCContainer" class="matrix-group" style="display:none;">
      <div class="matrix-label" id="resultMatrixLabel">Result</div>
      <table class="matrix-table" id="mainMatrixC"></table>
    </div>
  </div>

  <div style="text-align:center; margin-top:1.5em;">
    <span id="laplaceControls">
      <button class="button" id="animateLaplaceBtn">Animate Laplace Expansion</button>
    </span>
    <span id="multiplyControls" style="display:none;">
      <button class="button" id="animateMultiplyBtn">Animate Multiplication</button>
    </span>
  </div>
  <button id="skipAnimBtn" class="button">Skip Animation</button>
  <div id="stepLatex" class="latex-output fade-in"></div>
  <div id="finalResultLatex" class="latex-output fade-in"></div>
</div>
<button id="runFeatureTestBtn">Run Feature Test</button>

<script>
  const qs = (selector) => document.querySelector(selector);
  const qsa = (selector) => document.querySelectorAll(selector);

  const MODES = {
    laplace: {
      showB: false, showC: false, showOperator: false, operatorSymbol: '', resultLabel: '|A| Result',
      actionButton: 'animateLaplaceBtn', controlsId: 'laplaceControls', needsSquareA: true, defaultFillType: 'sym'
    },
    multiply: {
      showB: true, showC: true, showOperator: true, operatorSymbol: '×', resultLabel: 'A × B',
      actionButton: 'animateMultiplyBtn', controlsId: 'multiplyControls', needsSquareA: false, defaultFillType: 'num'
    }
  };
  let currentMode = "laplace";
  const MIN_SIZE = 1, MAX_SIZE = 6;

  let matrixA = [];
  let matrixB = [];
  let matrixC = [];

  let animationTimeout = null;
  let skipAnimationFlag = false;

  function safeRenderMath(element) {
      if (typeof renderMathInElement === 'function' && element) {
          renderMathInElement(element);
      }
  }

  // --- Matrix Utilities ---
  const Matrix = {
    create: (rows, cols, fillType = 'num', baseCharOrVal = 'a') => {
      let symCounter = 1;
      return Array.from({ length: rows }, (rIdx, r) =>
        Array.from({ length: cols }, (cIdx, c) => {
          if (fillType === 'num') return (Math.floor(Math.random() * 20) - 9).toString();
          if (fillType === 'sym') {
            if (rows === 3 && cols === 3 && baseCharOrVal === 'a') return `${baseCharOrVal}_${rIdx+1}${cIdx+1}`;
            return baseCharOrVal + (rows * cols > 1 ? symCounter++ : '');
          }
          if (fillType === 'zero') return '0';
          if (fillType === 'empty') return '';
          return "";
        })
      );
    },
    clone: m => m.map(r => r.slice()),
    isNumeric: m => { // Robust check for array of string-convertible numbers
        if (!m || !Array.isArray(m) || m.length === 0 || !Array.isArray(m[0]) || m[0].length === 0) return false;
        return m.flat().every(x => {
            const val = x === null || x === undefined ? '' : x.toString().trim();
            return val !== '' && !isNaN(parseFloat(val));
        });
    },
    parseNumeric: m => m.map(row => row.map(val => parseFloat(val.toString().trim()))),

    randomize: (matRef, matrixName) => {
        if (!matRef || matRef.length === 0 || !matRef[0]) return Matrix.create(1,1,'num'); 
        const rows = matRef.length;
        const cols = matRef[0].length;
        const currentFlat = matRef.flat().join(',');
        const type = 'num'; 
        const baseChar = matrixName === 'A' ? 'a' : String.fromCharCode('a'.charCodeAt(0) + (matrixA?.length * matrixA[0]?.length || 0) );

        let newMatrix;
        let attempts = 0;
        do {
            newMatrix = Matrix.create(rows, cols, type, baseChar);
            attempts++;
        } while (newMatrix.flat().join(',') === currentFlat && attempts < 20);
        return newMatrix;
    },

    determinant: (m) => { 
      if (!Matrix.isNumeric(m)) return NaN;
      const numMatrix = Matrix.parseNumeric(m);
      const n = numMatrix.length;
      if (numMatrix.flat().some(isNaN)) return NaN;
      if (n === 0 || n !== numMatrix[0]?.length) return NaN;

      if (n === 1) return numMatrix[0][0];
      if (n === 2) return numMatrix[0][0] * numMatrix[1][1] - numMatrix[0][1] * numMatrix[1][0];

      let det = 0;
      for (let j = 0; j < n; j++) {
        const minorValues = numMatrix.slice(1).map(row => row.filter((_, colIdx) => colIdx !== j));
        const minorMatrixForDeterminant = minorValues.map(row => row.map(String)); 
        det += numMatrix[0][j] * Math.pow(-1, j) * Matrix.determinant(minorMatrixForDeterminant);
      }
      return det;
    },

    multiply: (mA, mB) => {
      if (!Matrix.isNumeric(mA) || !Matrix.isNumeric(mB)) {
          return null;
      }
      const numA = Matrix.parseNumeric(mA);
      const numB = Matrix.parseNumeric(mB);

      if (numA.flat().some(isNaN) || numB.flat().some(isNaN)) {
        return null;
      }

      const rowsA = numA.length, colsA = numA[0]?.length, rowsB = numB.length, colsB = numB[0]?.length;
      if (colsA !== rowsB) {
          return null;
      }

      const result = Matrix.create(rowsA, colsB, 'zero');
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          let sum = 0;
          for (let k = 0; k < colsA; k++) {
            sum += numA[i][k] * numB[k][j];
          }
          if(isNaN(sum)) { // Should not happen if previous checks are fine
              console.error("NaN sum in multiply", numA[i][k], numB[k][j]); return null;
          }
          result[i][j] = sum.toString();
        }
      }
      return result;
    }
  };

  // --- Rendering & UI ---
  function populateSelect(selectId, min, max, defaultValue) {
    const sel = qs(`#${selectId}`);
    sel.innerHTML = "";
    for (let i = min; i <= max; i++) {
      sel.innerHTML += `<option value="${i}"${i == defaultValue ? " selected" : ""}>${i}</option>`;
    }
  }

  function setupDimensionControls() {
    const defaults = {aRows: matrixA?.length || 3, aCols: matrixA?.[0]?.length || 3, bCols: matrixB?.[0]?.length || 3};
    populateSelect('aRows', MIN_SIZE, MAX_SIZE, defaults.aRows);
    populateSelect('aCols', MIN_SIZE, MAX_SIZE, defaults.aCols);
    populateSelect('bCols', MIN_SIZE, MAX_SIZE, defaults.bCols);
    qs('#bRows').innerHTML = `<option value="${qs('#aCols').value}">${qs('#aCols').value}</option>`;
  }


  function updateMatrixDimensions() {
    clearTimeout(animationTimeout);
    qs('#skipAnimBtn').style.display = 'none';

    const aRows = parseInt(qs('#aRows').value);
    let aCols = parseInt(qs('#aCols').value);
    const bColsVal = qs('#bCols').value;
    const bCols = bColsVal ? parseInt(bColsVal) : aCols;
    const modeConfig = MODES[currentMode];

    if (modeConfig.needsSquareA && aRows !== aCols) {
        qs('#aCols').value = aRows; 
        aCols = aRows; 
    }
    
    matrixA = Matrix.create(aRows, aCols, modeConfig.defaultFillType, 'a');

    if (modeConfig.showB) {
      const bRows = aCols;
      qs('#bRows').innerHTML = `<option value="${bRows}">${bRows}</option>`;
      matrixB = Matrix.create(bRows, bCols, MODES.multiply.defaultFillType, String.fromCharCode('a'.charCodeAt(0) + (aRows*aCols || 0) ));
    } else {
      matrixB = [];
    }

    if (modeConfig.showC) {
      const resRows = currentMode === 'multiply' ? aRows : 0;
      const resCols = currentMode === 'multiply' ? bCols : 0;
      matrixC = (resRows > 0 && resCols > 0) ? Matrix.create(resRows, resCols, 'empty') : [];
    } else {
      matrixC = [];
    }
    renderUI();
    if (currentMode === 'multiply') updateMultiplyFinalLatex();
    else if (currentMode === 'laplace') updateLaplaceFinalLatex();
  }

  function renderMatrix(tableId, matrix, highlightFn = () => "") {
    const table = qs(`#${tableId}`);
    // Clear previous content more thoroughly
    while (table.firstChild) {
        table.removeChild(table.firstChild);
    }

    if (!matrix || matrix.length === 0) {
        const tr = table.insertRow();
        const td = tr.insertCell();
        td.style.cursor = "default";
        td.style.color = "#777";
        td.textContent = tableId === 'mainMatrixC' && MODES[currentMode].showC ? '(Result)' : '(N/A)';
        return;
    }
    
    matrix.forEach((row, i) => {
        const tr = table.insertRow();
        row.forEach((val, j) => {
            const td = tr.insertCell();
            td.className = highlightFn(i, j);
            td.textContent = val;
            // Add event listener directly
            td.addEventListener('click', function() { // Use function() for 'this' if needed, or arrow
                window.editCell(tableId, i, j);
            });
        });
    });
  }


  function renderUI() {
    const modeConfig = MODES[currentMode];

    renderMatrix('mainMatrixA', matrixA);
    qs('#matrixBContainer').style.display = modeConfig.showB ? "" : "none";
    if (modeConfig.showB) renderMatrix('mainMatrixB', matrixB);

    qs('#operatorSymbol').style.display = modeConfig.showOperator ? "" : "none";
    qs('#operatorSymbol').textContent = modeConfig.operatorSymbol;

    qs('#equalsSymbol').style.display = modeConfig.showC ? "" : "none";
    qs('#matrixCContainer').style.display = modeConfig.showC ? "" : "none";
    qs('#resultMatrixLabel').textContent = modeConfig.resultLabel;
    if (modeConfig.showC) renderMatrix('mainMatrixC', matrixC);

    Object.values(MODES).forEach(mc => {
        const controlsEl = qs(`#${mc.controlsId}`);
        if (controlsEl) controlsEl.style.display = mc.controlsId === modeConfig.controlsId ? "" : "none";
    });

    qs('#aCols').disabled = modeConfig.needsSquareA;
    qs('#bCols').disabled = !modeConfig.showB;
    qs('#randomB').style.display = modeConfig.showB ? "" : "none";
    
    const actionButton = qs(`#${modeConfig.actionButton}`);
    if(actionButton) {
        actionButton.disabled = (modeConfig.needsSquareA && (!matrixA || matrixA.length === 0 || matrixA.length !== matrixA[0]?.length));
    }

    qs('#stepLatex').innerHTML = "";
    qs('#skipAnimBtn').style.display = "none";
    clearTimeout(animationTimeout);
  }

  function updateLaplaceFinalLatex(isNumericOverride, symbolicResultString) {
    if (currentMode !== 'laplace' || !matrixA || matrixA.length === 0) {
        qs('#finalResultLatex').innerHTML = ''; return;
    }

    let displayText = "";
    if (matrixA.length !== matrixA[0]?.length) {
        displayText = '\\text{Not a square matrix}';
    } else {
        const isActuallyNumeric = (isNumericOverride === undefined) ? Matrix.isNumeric(matrixA) : isNumericOverride;
        if (isActuallyNumeric) {
            const detValue = Matrix.determinant(matrixA);
            displayText = isNaN(detValue) ? "\\text{Numeric Error}" : detValue.toString();
        } else if (symbolicResultString !== undefined && symbolicResultString !== "") {
            displayText = symbolicResultString;
        } else { 
            const n = matrixA.length;
            if (n === 1) displayText = matrixA[0][0].toString();
            else if (n === 2) {
                const m = matrixA.map(r => r.map(c => `(${c})`));
                displayText = `${m[0][0]}${m[1][1]} - ${m[0][1]}${m[1][0]}`;
            } else if (n === 3) {
                const m = matrixA.map(r => r.map(c => `(${c})`));
                const t1 = `${m[0][0]}((${m[1][1]})(${m[2][2]}) - (${m[1][2]})(${m[2][1]}))`;
                const t2 = `${m[0][1]}((${m[1][0]})(${m[2][2]}) - (${m[1][2]})(${m[2][0]}))`;
                const t3 = `${m[0][2]}((${m[1][0]})(${m[2][1]}) - (${m[1][1]})(${m[2][0]}))`;
                displayText = `${t1} - ${t2} + ${t3}`;
            } else {
                 displayText = `\\left|\\begin{array}{${"c".repeat(n)}}${matrixA.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right| \\text{ (Symbolic N > 3)}`;
            }
        }
    }
    qs('#finalResultLatex').innerHTML = `$$|A| = ${displayText}$$`;
    safeRenderMath(qs('#finalResultLatex'));
  }


  function updateMultiplyFinalLatex() {
    if (currentMode !== 'multiply') { qs('#finalResultLatex').innerHTML = ''; return; }

    if (matrixC && matrixC.length > 0 && matrixC[0]?.length > 0) {
        let cLatex;
        const isResultNumeric = matrixC.every(row => row.every(cell => cell !== null && cell.toString().trim() !== '' && !isNaN(parseFloat(cell.toString().trim()))));

        if (isResultNumeric) {
            cLatex = matrixC.map(row => row.join(' & ')).join('\\\\ ');
        } else { 
            cLatex = matrixC.map(row => row.map(cell => {
                const cellStr = cell === null || cell === undefined ? '' : cell.toString();
                if (cellStr.trim() === '') return '?';
                return cellStr.replace(/\*/g, '\\cdot ').replace(/\\times/g, '\\cdot ');
            }).join(' & ')).join('\\\\ ');
        }
        qs('#finalResultLatex').innerHTML = `$$ C = \\begin{pmatrix} ${cLatex} \\end{pmatrix} $$`;
    } else if (matrixA?.[0]?.length !== matrixB?.length && matrixA?.length > 0 && matrixB?.length > 0) { 
        qs('#finalResultLatex').innerHTML = `$$ C = \\text{Incompatible Dimensions for A \u00D7 B} $$`;
    } else {
        qs('#finalResultLatex').innerHTML = '$$ C = \\text{(N/A)} $$'; 
    }
    safeRenderMath(qs('#finalResultLatex'));
  }

  window.editCell = function(tableId, r, c) { 
    try {
      console.log('[DEBUG] editCell invoked (event listener):', tableId, `(${r},${c})`);

      let matrixToUpdateRef; 
      let matrixName = '';

      if (tableId === 'mainMatrixA') {
        matrixToUpdateRef = matrixA;
        matrixName = 'Matrix A';
      } else if (tableId === 'mainMatrixB') {
        matrixToUpdateRef = matrixB;
        matrixName = 'Matrix B';
      } else {
        console.error('[DEBUG] editCell called for invalid tableId:', tableId);
        return; 
      }

      if (!matrixToUpdateRef || !matrixToUpdateRef[r] || typeof matrixToUpdateRef[r][c] === 'undefined') {
          console.error('[DEBUG] Cell data undefined for:', tableId, `(${r},${c})`, matrixToUpdateRef);
          alert("Error: Cell data is undefined. Cannot edit.");
          return;
      }

      const currentValue = matrixToUpdateRef[r][c];
      const promptedValue = prompt(`Enter value for cell (${r+1},${c+1}) of ${matrixName}:`, currentValue);

      if (promptedValue !== null) {
        const trimmedValue = promptedValue.trim();
        matrixToUpdateRef[r][c] = trimmedValue === '' ? '0' : trimmedValue;
        
        console.log('[DEBUG] Cell updated in model. Re-rendering UI and calculating results.');
        renderUI(); 

        if (currentMode === 'multiply') {
          if (Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB) && matrixA[0]?.length === matrixB.length) {
            matrixC = Matrix.multiply(matrixA, matrixB);
          } else {
            const rowsA = matrixA.length;
            const colsB = matrixB[0]?.length || 0; 
            matrixC = (rowsA > 0 && colsB > 0) ? Matrix.create(rowsA, colsB, 'empty') : [];
          }
          if(!matrixC) matrixC = []; 
          renderMatrix('mainMatrixC', matrixC); 
          updateMultiplyFinalLatex(); 
        } else if (currentMode === 'laplace') {
          updateLaplaceFinalLatex(); 
        }
      } else {
        console.log('[DEBUG] Prompt cancelled by user for cell:', tableId, `(${r},${c})`);
      }
    } catch (e) {
      console.error('[DEBUG] Error in editCell:', tableId, `(${r},${c})`, e);
      alert('An error occurred while trying to edit the cell. Check console.');
    }
  };


  function switchMode(newMode) {
    currentMode = newMode;
    setupDimensionControls(); 
    updateMatrixDimensions(); 
  }

  function randomizeMatrix(matrixIdentifier) {
    let targetMatrixRef;
    if (matrixIdentifier === 'A') targetMatrixRef = matrixA;
    else if (matrixIdentifier === 'B') targetMatrixRef = matrixB;
    else return;

    if (targetMatrixRef && targetMatrixRef.length > 0 && targetMatrixRef[0]) { // Check if matrix exists and has columns
        if (matrixIdentifier === 'A') matrixA = Matrix.randomize(matrixA, 'A');
        else matrixB = Matrix.randomize(matrixB, 'B');
    } else { 
        const rows = parseInt(qs(matrixIdentifier === 'A' ? '#aRows' : '#bRows').value) || 2;
        const cols = parseInt(qs(matrixIdentifier === 'A' ? '#aCols' : '#bCols').value) || 2;
        const createdMatrix = Matrix.create(rows, cols, 'num'); // Create with 'num'
        if (matrixIdentifier === 'A') matrixA = Matrix.randomize(createdMatrix, 'A'); // Then randomize (which also uses 'num')
        else if (matrixIdentifier === 'B') matrixB = Matrix.randomize(createdMatrix, 'B');
    }

    renderUI();
    if (currentMode === 'multiply') {
        if (Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB) && matrixA[0]?.length === matrixB.length) {
            matrixC = Matrix.multiply(matrixA, matrixB);
        } else {
            const rowsA = matrixA?.length || 0;
            const colsB = matrixB?.[0]?.length || 0;
            matrixC = (rowsA > 0 && colsB > 0) ? Matrix.create(rowsA, colsB, 'empty') : [];
        }
        if(!matrixC) matrixC = [];
        renderMatrix('mainMatrixC', matrixC);
        updateMultiplyFinalLatex();
    } else if (currentMode === 'laplace') {
        updateLaplaceFinalLatex();
    }
  }

  // --- Animation Logic ---
  function startLaplaceExpansion() {
    if (!matrixA || matrixA.length === 0 || !matrixA[0] || matrixA.length !== matrixA[0].length) {
      qs('#stepLatex').innerHTML = "<div class='fade-in'><b>Error: Matrix A must be square for determinant.</b></div>";
      return;
    }
    clearTimeout(animationTimeout);
    skipAnimationFlag = false;
    qs('#skipAnimBtn').style.display = "inline-block";
    qs('#stepLatex').innerHTML = "";
    
    const n = matrixA.length;
    let currentStep = 0;
    const originalMatrixLatex = `|A| = \\left|\\begin{array}{${"c".repeat(n)}}${matrixA.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right|`;
    
    updateLaplaceFinalLatex();

    let accumulatedLatexTerms = "";

    function animateNextLaplaceStep() {
      if (skipAnimationFlag) { currentStep = n; }

      if (currentStep < n) {
        renderMatrix('mainMatrixA', matrixA, (r, c) => {
          if (r === 0 && c === currentStep) return 'selected'; 
          if (r > 0 && c !== currentStep) return 'minor'; 
          return '';
        });

        const pivot = `(${matrixA[0][currentStep]})`;
        const sign = (currentStep % 2 === 0) ? "+" : "-";
        const minorMatrix = matrixA.slice(1).map(row => row.filter((_, colIdx) => colIdx !== currentStep));
        
        let minorLatexString = "1"; 
        if (n > 1 && minorMatrix.length > 0 && minorMatrix[0]?.length > 0) {
             minorLatexString = `\\left|\\begin{array}{${"c".repeat(n-1)}}${minorMatrix.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right|`;
        } else if (n > 1 && (minorMatrix.length === 0 || (minorMatrix[0] && minorMatrix[0].length === 0)) && n-1 > 0) { 
            minorLatexString = "\\text{(empty minor)}"; 
        }


        let currentTermLatex = "";
        if (currentStep === 0 && sign === "+") currentTermLatex = `${pivot} ${minorLatexString}`;
        else currentTermLatex = ` ${sign} ${pivot} ${minorLatexString}`;
        
        accumulatedLatexTerms += currentTermLatex;

        qs('#stepLatex').innerHTML = `<div class="fade-in">$$ ${originalMatrixLatex} = ${accumulatedLatexTerms} ${currentStep < n-1 ? "..." : ""} $$</div>`;
        safeRenderMath(qs('#stepLatex'));

        currentStep++;
        animationTimeout = setTimeout(animateNextLaplaceStep, skipAnimationFlag ? 1 : 1800);
      } else { 
        renderMatrix('mainMatrixA', matrixA); 
        const isNumericInput = Matrix.isNumeric(matrixA);
        let finalSymbolicResult = "";
        let finalNumericResult = NaN;

        if (isNumericInput) {
            finalNumericResult = Matrix.determinant(matrixA);
        } else { 
            if (n === 1) {
                finalSymbolicResult = matrixA[0][0].toString();
            } else if (n === 2) {
                const m = matrixA.map(r => r.map(c => `(${c})`));
                finalSymbolicResult = `${m[0][0]}${m[1][1]} - ${m[0][1]}${m[1][0]}`;
            } else if (n === 3) {
                const m = matrixA.map(r => r.map(c => `(${c})`));
                const t1 = `${m[0][0]}((${m[1][1]})(${m[2][2]}) - (${m[1][2]})(${m[2][1]}))`;
                const t2 = `${m[0][1]}((${m[1][0]})(${m[2][2]}) - (${m[1][2]})(${m[2][0]}))`;
                const t3 = `${m[0][2]}((${m[1][0]})(${m[2][1]}) - (${m[1][1]})(${m[2][0]}))`;
                finalSymbolicResult = `${t1} - ${t2} + ${t3}`;
            }
        }
        
        let expansionTermsToShow = accumulatedLatexTerms.trim();
        if ((skipAnimationFlag && expansionTermsToShow === "") || expansionTermsToShow === "") { 
            expansionTermsToShow = ""; 
            for (let j = 0; j < n; j++) {
                const currentPivot = `(${matrixA[0][j]})`;
                const currentSign = (j % 2 === 0) ? (j > 0 ? "+" : "") : "-";
                const currentMinorMatrix = matrixA.slice(1).map(row => row.filter((_, colIdx) => colIdx !== j));
                let currentMinorLatex = "1";
                if (n > 1 && currentMinorMatrix.length > 0 && currentMinorMatrix[0]?.length > 0) {
                     currentMinorLatex = `\\left|\\begin{array}{${"c".repeat(n - 1)}}${currentMinorMatrix.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right|`;
                }
                expansionTermsToShow += `${currentSign} ${currentPivot} ${currentMinorLatex} `;
            }
            expansionTermsToShow = expansionTermsToShow.trim();
        }
        
        let resultValueText = "";
        if (isNumericInput) {
            resultValueText = isNaN(finalNumericResult) ? "= \\text{Numeric Error}" : `= ${finalNumericResult}`;
        } else if (finalSymbolicResult !== "") {
            resultValueText = `= ${finalSymbolicResult}`;
        } else if (n > 3 && !isNumericInput) { 
            resultValueText = `\\quad \\text{(Symbolic N > 3 Expansion Shown by Terms)}`;
        } else if (!isNumericInput && n > 0) { // Fallback for other symbolic cases not explicitly handled.
             resultValueText = `\\quad \\text{(Symbolic Result)}`;
        }


        qs('#stepLatex').innerHTML = `<div class="fade-in">$$ ${originalMatrixLatex} = ${expansionTermsToShow} ${resultValueText} $$</div>`;
        safeRenderMath(qs('#stepLatex'));
        qs('#skipAnimBtn').style.display = "none";
        updateLaplaceFinalLatex(isNumericInput, finalSymbolicResult || (isNumericInput && !isNaN(finalNumericResult) ? finalNumericResult.toString() : undefined));
      }
    }
    animateNextLaplaceStep();
  }

  function startMatrixMultiplication() {
    if (!matrixA || matrixA.length === 0 || !matrixA[0] || !matrixB || matrixB.length === 0 || !matrixB[0] || matrixA[0].length !== matrixB.length) {
      qs('#stepLatex').innerHTML = "<div class='fade-in'><b>Error: Incompatible dimensions for multiplication. Columns of A must equal Rows of B.</b></div>";
      updateMultiplyFinalLatex(); 
      return;
    }
    clearTimeout(animationTimeout);
    skipAnimationFlag = false;
    qs('#skipAnimBtn').style.display = "inline-block";
    qs('#stepLatex').innerHTML = "";

    const rowsA = matrixA.length;
    const colsA = matrixA[0].length; 
    const colsB = matrixB[0].length;
    matrixC = (rowsA > 0 && colsB > 0) ? Matrix.create(rowsA, colsB, 'empty') : [];
    renderMatrix('mainMatrixC', matrixC); 
    updateMultiplyFinalLatex();


    let animState = { rA: 0, cB: 0, k: 0, currentSumLatex: "" };

    function animateNextMultiplyStep() {
      if (skipAnimationFlag) {
        if(Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB)) {
            matrixC = Matrix.multiply(matrixA, matrixB);
        } else {
             matrixC = (rowsA > 0 && colsB > 0) ? Matrix.create(rowsA, colsB, 'empty') : []; 
        }
        if (!matrixC) matrixC = (rowsA > 0 && colsB > 0) ? Matrix.create(rowsA, colsB, 'empty') : [];

        renderMatrix('mainMatrixC', matrixC);
        qs('#stepLatex').innerHTML = "<div class='fade-in'><b>Multiplication Complete (Skipped)</b></div>";
        qs('#skipAnimBtn').style.display = "none";
        updateMultiplyFinalLatex();
        return;
      }

      const { rA, cB, k } = animState;

      renderMatrix('mainMatrixA', matrixA, (r, c) => (r === rA && c === k) ? 'term-highlight' : (r === rA ? 'mul-row' : ''));
      renderMatrix('mainMatrixB', matrixB, (r, c) => (r === k && c === cB) ? 'term-highlight' : (c === cB ? 'mul-col' : ''));
      renderMatrix('mainMatrixC', matrixC, (r, c) => (r === rA && c === cB) ? 'mul-cell' : '');

      const valA = matrixA[rA][k];
      const valB = matrixB[k][cB];
      const term = (!isNaN(parseFloat(valA)) && !isNaN(parseFloat(valB))) ? (parseFloat(valA) * parseFloat(valB)).toString() : `(${valA}) \\cdot (${valB})`;
      
      if (k === 0) animState.currentSumLatex = ""; 
      animState.currentSumLatex += (k > 0 ? " + " : "") + term;

      qs('#stepLatex').innerHTML = `<div class="fade-in">$$ c_{${rA+1}${cB+1}} = ${animState.currentSumLatex} $$</div>`;
      safeRenderMath(qs('#stepLatex'));

      if (k < colsA - 1) {
        animState.k++;
      } else { 
        let cellValue = 0;
        let isNumericCalculation = true;
        let symbolicSumForCell = ""; 
        for(let sumIdx = 0; sumIdx < colsA; sumIdx++){
            const numA_val = matrixA[rA][sumIdx];
            const numB_val = matrixB[sumIdx][cB];
            const currentTermSym = `(${numA_val}) \\cdot (${numB_val})`;
            symbolicSumForCell += (sumIdx > 0 ? " + " : "") + currentTermSym;

            const numA = parseFloat(numA_val);
            const numB = parseFloat(numB_val);
            if(isNaN(numA) || isNaN(numB)){
                isNumericCalculation = false;
            }
            if(isNumericCalculation) cellValue += numA * numB;
        }
        matrixC[rA][cB] = isNumericCalculation ? cellValue.toString() : symbolicSumForCell.replace(/\s/g,'');
        renderMatrix('mainMatrixC', matrixC, (r, c) => (r === rA && c === cB) ? 'mul-cell' : ''); 
        
        animState.k = 0;
        if (cB < colsB - 1) {
          animState.cB++;
        } else {
          animState.cB = 0;
          if (rA < rowsA - 1) {
            animState.rA++;
          } else { 
            renderMatrix('mainMatrixA', matrixA); 
            renderMatrix('mainMatrixB', matrixB); 
            qs('#stepLatex').innerHTML += "<div class='fade-in'><b>Multiplication Complete!</b></div>";
            if (Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB)) { 
                matrixC = Matrix.multiply(matrixA, matrixB); 
                if (!matrixC) matrixC = (rowsA > 0 && colsB > 0) ? Matrix.create(rowsA, colsB, 'empty') : [];
                renderMatrix('mainMatrixC', matrixC); 
            }
            qs('#skipAnimBtn').style.display = "none";
            updateMultiplyFinalLatex();
            return; 
          }
        }
      }
      animationTimeout = setTimeout(animateNextMultiplyStep, skipAnimationFlag ? 1 : 1200);
    }
    animateNextMultiplyStep();
  }


  // --- Initialization ---
  document.addEventListener('DOMContentLoaded', () => {
    qs('#modeLaplaceBtn').addEventListener('click', () => switchMode('laplace'));
    qs('#modeMultiplyBtn').addEventListener('click', () => switchMode('multiply'));

    qsa('#aRows, #aCols, #bCols').forEach(sel => sel.addEventListener('change', updateMatrixDimensions));
    qs('#aCols').addEventListener('change', () => { 
        const newAColsValue = qs('#aCols').value;
        qs('#bRows').innerHTML = `<option value="${newAColsValue}">${newAColsValue}</option>`;
    });

    qs('#animateLaplaceBtn').addEventListener('click', startLaplaceExpansion);
    qs('#animateMultiplyBtn').addEventListener('click', startMatrixMultiplication);
    qs('#skipAnimBtn').addEventListener('click', () => { skipAnimationFlag = true; });

    qs('#randomA').addEventListener('click', () => randomizeMatrix('A'));
    qs('#randomB').addEventListener('click', () => randomizeMatrix('B'));
    
    switchMode('laplace'); 
  });

  // --- Feature Test --- 
  qs('#runFeatureTestBtn').onclick = function runFeatureTest() {
    (function(){
      let testLogEl = qs('#_featureTestLog');
      if (testLogEl) testLogEl.remove(); 

      function log(msg, pass) {
        let el = qs('#_featureTestLog');
        if (!el) {
          el = document.createElement('div');
          el.id = '_featureTestLog';
          el.style.cssText = 'position:fixed;bottom:8px;left:8px;background:#151b23;color:#ffe165;padding:1em 1.4em;border-radius:11px;font-size:0.9em;z-index:10000;max-width:450px;max-height:300px;overflow-y:auto;box-shadow:0 2px 16px #000a;';
          el.innerHTML = '<b>Feature Test Results</b><br>';
          document.body.appendChild(el);
        }
        el.innerHTML += `<div style="margin-top:4px;border-bottom:1px solid #333842;padding-bottom:3px;"><b style="color:${pass ? '#8fe388':'#ff8d8d'}">${pass?'✔':'✖'}</b> <span>${msg}</span></div>`;
        el.scrollTop = el.scrollHeight;
      }

      function getTableData(tableId, asNumber = true) {
        let mat = [], trs = qs(`#${tableId}`)?.querySelectorAll('tr');
        if (!trs || trs.length === 0 ) return []; 
        const firstCell = trs[0].querySelector('td');
        if (!firstCell) return []; // No cells in the first row
        const firstCellText = firstCell.textContent || "";
        if (trs.length === 1 && (firstCellText.includes('(N/A)') || firstCellText.includes('(Result)') || firstCellText.trim() === '')) return [];

        for (let tr of trs) {
          let row = [];
          for (let td of tr.querySelectorAll('td')) {
            const content = td.textContent;
            if (content === null || content.trim() === '' || content === '\u00A0') { 
                 row.push(asNumber ? NaN : ''); 
            } else {
                 row.push(asNumber ? Number(content) : content);
            }
          }
           if (row.length > 0) { // Only add non-empty rows based on content
             if (mat.length === 0 || row.length === mat[0].length) { // Ensure consistent column count
                mat.push(row);
             } else {
                log(`Warning: Inconsistent row length in getTableData for ${tableId}. Row: ${JSON.stringify(row)}, Matrix so far: ${JSON.stringify(mat)}`, false)
             }
          }
        }
        return mat;
      }


      async function testAllCellEdits(matrixId, vals) {
        log(`Attempting to edit ${matrixId} to ${JSON.stringify(vals)}`, true);
        let table = qs(`#${matrixId}`), trs = table.querySelectorAll('tr');
        if(vals.length === 0 || (vals.length > 0 && vals[0].length === 0)) {
            log(`Skipping cell edit test for ${matrixId} due to empty test values.`, true); // Not a failure of editing
            return true; 
        }
         // Wait for table to be populated
        await new Promise(resolve => setTimeout(resolve, 100));
        trs = qs(`#${matrixId}`)?.querySelectorAll('tr'); // Re-query table rows

        if (!trs || trs.length === 0 || (trs[0] && (trs[0].textContent.includes('(N/A)') || trs[0].textContent.includes('(Result)')))) {
             log(`Cannot edit ${matrixId}, table not rendered or N/A. Rows: ${trs?.length}`, false);
             return false;
        }
        if (trs.length !== vals.length || (trs.length > 0 && (!trs[0].querySelectorAll('td') || trs[0].querySelectorAll('td').length !== vals[0].length))) {
           log(`Dimension mismatch for ${matrixId}. Table: ${trs?.length}x${trs[0]?.querySelectorAll('td').length}, Test Data: ${vals.length}x${vals[0].length}`, false);
           return false;
        }

        const originalPrompt = window.prompt;
        let allEditsSuccessful = true;
        for(let i=0; i<vals.length; ++i) {
            for(let j=0; j<vals[0].length; ++j) {
                window.prompt = (message, defaultValue) => String(vals[i][j]);
                window.editCell(matrixId, i, j); // Directly call the function the event listener would
                
                const dataModel = (matrixId === 'mainMatrixA') ? matrixA : matrixB;
                if (!dataModel || !dataModel[i] || dataModel[i][j] !== String(vals[i][j])) {
                     log(`Data model edit check failed for ${matrixId}[${i}][${j}] to ${vals[i][j]}. Got ${dataModel?.[i]?.[j]}`, false);
                    allEditsSuccessful = false;
                }
            }
        }
        window.prompt = originalPrompt;

        await new Promise(resolve => setTimeout(resolve, 350)); 

        let finalTableData = getTableData(matrixId, false); 
        let allMatch = vals.every((row, i) => row.every((val, j) => String(val) === finalTableData[i]?.[j]));
        
        if (!allMatch) { 
            log(`Final table check mismatch for ${matrixId}. Expected: ${JSON.stringify(vals)}, Got: ${JSON.stringify(finalTableData)}`, false);
        }
        log(`All cells in "${matrixId}" editable and update correctly to ${JSON.stringify(vals)}`, allMatch && allEditsSuccessful);
        return allMatch && allEditsSuccessful;
      }
      
      async function testSymbolicDeterminant() {
        log('--- Testing Symbolic Determinant (3x3 Curl-like) ---', true);
        qs('#modeLaplaceBtn').click();
        await new Promise(resolve => setTimeout(resolve, 200));

        qs('#aRows').value = 3; qs('#aCols').value = 3;
        qs('#aRows').dispatchEvent(new Event('change')); 
        await new Promise(resolve => setTimeout(resolve, 250)); 

        const curlMatrix = [["i", "j", "k"], ["\\partial_x", "\\partial_y", "\\partial_z"], ["Fx", "Fy", "Fz"]];
        const editSuccessCurl = await testAllCellEdits('mainMatrixA', curlMatrix); 
        if(!editSuccessCurl) { log("Aborting Symbolic Det test due to cell edit failure.", false); return; }
        
        qs('#animateLaplaceBtn').click();
        await new Promise(resolve => setTimeout(resolve, 100)); 
        if(qs('#skipAnimBtn').style.display !== 'none') qs('#skipAnimBtn').click();
        await new Promise(resolve => setTimeout(resolve, 700)); 

        const stepLatex = qs('#stepLatex').textContent || "";
        
        const term1_expected = "(i)(((\\partial_y))((Fz))-((\\partial_z))((Fy)))"; 
        const term2_expected = "(j)(((\\partial_x))((Fz))-((\\partial_z))((Fx)))";
        const term3_expected = "(k)(((\\partial_x))((Fy))-((\\partial_y))((Fx)))";
        
        const normalizedStepLatex = stepLatex.replace(/\s+/g, ''); // Remove all spaces for comparison

        // Check for the pattern: ... = (cofactor_sum) = (algebraic_expansion)
        // The algebraic_expansion part should contain these terms.
        const algebraicPart = normalizedStepLatex.split('=').pop() || ""; // Get the part after the last '='


        const pass = algebraicPart.includes(term1_expected.replace(/\s+/g, '')) &&
                     algebraicPart.includes(`-${term2_expected.replace(/\s+/g, '')}`) &&
                     algebraicPart.includes(`+${term3_expected.replace(/\s+/g, '')}`);

        log(`Symbolic 3x3 determinant for curl-like structure is correct: ${pass}`, pass);
        if(!pass) {
            log(`T1 search in alg part: ${term1_expected.replace(/\s+/g, '')}`, false);
            log(`T2 search in alg part: -${term2_expected.replace(/\s+/g, '')}`, false);
            log(`T3 search in alg part: +${term3_expected.replace(/\s+/g, '')}`, false);
            log(`Actual normalized algebraicPart: ${algebraicPart}`, false);
            log(`Full normalized stepLatex: ${normalizedStepLatex}`, false);
        }
      }


      async function testLaplaceExpansion() {
        log('--- Testing Laplace Expansion (Numeric) ---', true);
        qs('#modeLaplaceBtn').click();
        await new Promise(resolve => setTimeout(resolve, 200));

        qs('#aRows').value = 3; qs('#aCols').value = 3;
        qs('#aRows').dispatchEvent(new Event('change')); 
        await new Promise(resolve => setTimeout(resolve, 200));
        
        qs('#randomA').click(); 
        await new Promise(resolve => setTimeout(resolve, 150));
        const testMatrixA_Laplace = [["1","2","3"],["0","4","5"],["1","0","6"]]; 
        const editSuccessLaplace = await testAllCellEdits('mainMatrixA', testMatrixA_Laplace);

        if(!editSuccessLaplace) { log("Aborting Laplace test due to cell edit failure.", false); return; }
        
        qs('#animateLaplaceBtn').click();
        await new Promise(resolve => setTimeout(resolve, 100)); 
        if(qs('#skipAnimBtn').style.display !== 'none') qs('#skipAnimBtn').click();
        await new Promise(resolve => setTimeout(resolve, 500));

        const finalLatexDet = qs('#finalResultLatex').textContent || "";
        const stepLatexDet = qs('#stepLatex').textContent || "";

        const expectedDeterminantValue = 22; 
        const expectedDeterminantString = `= ${expectedDeterminantValue}`;

        const passDetFinal = finalLatexDet.includes(expectedDeterminantString);
        // For step, we expect " = Cofactors = Value"
        const passDetStep = stepLatexDet.includes(expectedDeterminantString) && stepLatexDet.split('=').length >=3 ; 
        log(`Numeric Laplace final for ${JSON.stringify(testMatrixA_Laplace)} -> det = ${expectedDeterminantValue}`, passDetFinal);
        log(`Numeric Laplace step for ${JSON.stringify(testMatrixA_Laplace)} -> det = ${expectedDeterminantValue}`, passDetStep);
         if(!passDetStep) log(`Actual stepLatex for numeric: ${stepLatexDet}`, false);
      }

      async function testMultiplicationMode() {
        log('--- Testing Matrix Multiplication ---', true);
        qs('#modeMultiplyBtn').click();
        await new Promise(resolve => setTimeout(resolve, 200));

        qs('#aRows').value = 2; qs('#aCols').value = 2; qs('#bCols').value = 2;
        qs('#aRows').dispatchEvent(new Event('change')); 
        await new Promise(resolve => setTimeout(resolve, 250));

        const testMatrixA_Mult_Str = [["2","1"],["0","1"]]; 
        const testMatrixB_Mult_Str = [["3","4"],["1","2"]];
        
        const editASuccess = await testAllCellEdits('mainMatrixA', testMatrixA_Mult_Str);
        if(!editASuccess) { log("Aborting Multiply test due to cell edit failure on Matrix A.", false); return; }
        const editBSuccess = await testAllCellEdits('mainMatrixB', testMatrixB_Mult_Str);
        if(!editBSuccess) { log("Aborting Multiply test due to cell edit failure on Matrix B.", false); return; }
        
        matrixA = testMatrixA_Mult_Str.map(row => row.slice()); // Ensure global matrixA is correct
        matrixB = testMatrixB_Mult_Str.map(row => row.slice()); // Ensure global matrixB is correct

        qs('#animateMultiplyBtn').click();
        await new Promise(resolve => setTimeout(resolve, 100));
        if(qs('#skipAnimBtn').style.display !== 'none') qs('#skipAnimBtn').click();
        await new Promise(resolve => setTimeout(resolve, 500));

        const resultC_data_num = getTableData('mainMatrixC', true); 
        const expectedC_data_num = [[7,10],[1,2]]; 
        const passMultTable = JSON.stringify(resultC_data_num) === JSON.stringify(expectedC_data_num);
        log(`Multiply table [[2,1],[0,1]] x [[3,4],[1,2]] = ${JSON.stringify(expectedC_data_num)}`, passMultTable);
         if(!passMultTable) log(`Actual table C data (numbers): ${JSON.stringify(resultC_data_num)}`, false);


        const finalLatexMult = qs('#finalResultLatex').textContent || "";
        let passMultLatex = true;
        if (resultC_data_num.length > 0) { // Only check LaTeX if table data was somewhat populated
            for(const row of expectedC_data_num) {
                for(const val of row) {
                    if(!finalLatexMult.includes(val.toString())) {
                        passMultLatex = false; break;
                    }
                }
                if(!passMultLatex) break;
            }
        } else {
            passMultLatex = false; // If table data was empty, LaTeX probably is too or shows error
        }
        log(`Multiply LaTeX contains result ${JSON.stringify(expectedC_data_num)}`, passMultLatex);
        if(!passMultLatex) log(`Actual mult LaTeX: ${finalLatexMult}`, false)
      }
      
      async function runAllTests() {
        try {
            await testLaplaceExpansion(); 
            await new Promise(resolve => setTimeout(resolve, 400));
            await testSymbolicDeterminant(); 
            await new Promise(resolve => setTimeout(resolve, 400)); 
            await testMultiplicationMode();
            log('--- All Tests Completed ---', true);
        } catch (e) {
            log(`Testing Error: ${e.message} ${e.stack}`, false);
            console.error("Test suite error:", e);
        }
      }
      setTimeout(runAllTests, 300); 
    })();
  };
</script>
</body>
</html>