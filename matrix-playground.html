<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Matrix Visual Calculator</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
          onload="renderMathInElement(document.body, {delimiters:[{left:'$$', right:'$$', display:true}]});"></script>
  <style>
    body { background: #181c23; color: #f6f8fa; font-family: sans-serif; margin:0; padding-bottom: 80px; /* Space for test log */ }
    .demo-container { max-width: 900px; margin: 2em auto; background: #23272f; border-radius: 16px; box-shadow: 0 0 28px #1117; padding: 1.6em; }
    .matrix-flex { display: flex; gap: 1.5em; justify-content: center; align-items: flex-start; flex-wrap: wrap;}
    .matrix-label { text-align: center; font-weight: bold; margin-bottom: 0.4em; font-size: 1.1em; }
    .matrix-table { margin: 0 auto; border-collapse: collapse; position: relative; }
    .matrix-table td { width: 2.8em; height: 2.8em; font-size: 1.1em; text-align: center; border: 2px solid #555; background: #23272f; border-radius: 7px; color: #fff; cursor:pointer; transition: background 0.2s, color 0.2s; }
    .matrix-table td.selected { background: #4fa3ff; color: #23272f; font-weight: bold; } /* Pivot for Laplace */
    .matrix-table td.minor { background: #ffe165; color: #23272f; } /* Minor cells for Laplace */
    .matrix-table td.mul-row { background: #6fd6ffcc; color: #23272f; } /* Row for multiplication */
    .matrix-table td.mul-col { background: #ff6c90cc; color: #23272f; } /* Column for multiplication */
    .matrix-table td.mul-cell { background: #f5e960; color: #23272f; font-weight: bold;} /* Result cell for multiplication */
    .matrix-table td.term-highlight { background: #ff965acc; color: #23272f; font-weight: bold; } /* Current terms being multiplied */
    .button { background: #333e52; color: #fff; padding: 0.4em 1.2em; border: none; border-radius: 6px; font-size: 1em; font-weight: 600; margin: 0 0.6em 0.7em 0; cursor: pointer; transition: background 0.2s; }
    .button:hover { background: #2196f3; }
    .button:disabled { background: #2a313f; color: #777; cursor: not-allowed; }
    .mode-toggle { margin-bottom: 1.5em; text-align: center; }
    .matrix-group { display: flex; flex-direction: column; align-items: center; }
    .operator-display { font-size: 2em; line-height: 3em; margin: 0 0.5em; }
    .matrix-controls { margin-bottom: 0.4em; text-align: center;}
    .matrix-controls select { background:#292e39; color:#ffe165; border:1px solid #333e52; border-radius:6px; font-size:1em; margin:0 0.4em; padding: 0.2em;}
    .fade-in { animation: fadein 0.5s; }
    @keyframes fadein { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    #skipAnimBtn { position:fixed; right:28px; bottom:20px; z-index:2222; display:none;}
    #runFeatureTestBtn {
      position:fixed;top:24px;right:32px;z-index:9999;background:#181c23;color:#ffe165;
      padding:0.6em 1.1em;border-radius:7px;font-size:1em;font-weight:700;box-shadow:0 2px 9px #000a;
      border:2px solid #ffe165;cursor:pointer;
    }
    .latex-output { margin-top: 1em; padding: 0.5em; background: #2a313f55; border-radius: 8px; min-height: 2em; }
    @media (max-width: 900px) {
      .matrix-flex { flex-direction: column; align-items: stretch; gap: 1em;}
      .demo-container { padding: 1em; margin: 1em; }
      #skipAnimBtn { right:10px; bottom:10px; padding: 0.3em 0.8em; }
      .operator-display { line-height: 1.5em; margin: 0.5em 0; }
      .matrix-table td {width: 2.2em; height: 2.2em; font-size:1em;}
    }
  </style>
</head>
<body>
<div class="demo-container">
  <h2>Matrix Visual Calculator</h2>
  <div class="mode-toggle">
    <button class="button" id="modeLaplaceBtn">Laplace Expansion (Determinant)</button>
    <button class="button" id="modeMultiplyBtn">Matrix Multiply</button>
  </div>
  <div class="matrix-flex">
    <div class="matrix-group">
      <div class="matrix-label">Matrix A</div>
      <div class="matrix-controls">
        Rows: <select id="aRows"></select> &nbsp; Columns: <select id="aCols"></select>
      </div>
      <table class="matrix-table" id="mainMatrixA"></table>
      <div style="text-align:center; margin-top:0.5em;"><button class="button" id="randomA">Randomize A</button></div>
    </div>

    <div id="operatorSymbol" class="operator-display" style="display:none;"></div>

    <div id="matrixBContainer" class="matrix-group" style="display:none;">
      <div class="matrix-label">Matrix B</div>
      <div class="matrix-controls">
        Rows: <select id="bRows" disabled></select> &nbsp; Columns: <select id="bCols"></select>
      </div>
      <table class="matrix-table" id="mainMatrixB"></table>
      <div style="text-align:center; margin-top:0.5em;"><button class="button" id="randomB">Randomize B</button></div>
    </div>

    <div id="equalsSymbol" class="operator-display" style="display:none;">=</div>

    <div id="matrixCContainer" class="matrix-group" style="display:none;">
      <div class="matrix-label" id="resultMatrixLabel">Result</div>
      <table class="matrix-table" id="mainMatrixC"></table>
    </div>
  </div>

  <div style="text-align:center; margin-top:1.5em;">
    <span id="laplaceControls">
      <button class="button" id="animateLaplaceBtn">Animate Laplace Expansion</button>
    </span>
    <span id="multiplyControls" style="display:none;">
      <button class="button" id="animateMultiplyBtn">Animate Multiplication</button>
    </span>
  </div>
  <button id="skipAnimBtn" class="button">Skip Animation</button>
  <div id="stepLatex" class="latex-output fade-in"></div>
  <div id="finalResultLatex" class="latex-output fade-in"></div>
</div>
<button id="runFeatureTestBtn">Run Feature Test</button>

<script>
  const qs = (selector) => document.querySelector(selector);
  const qsa = (selector) => document.querySelectorAll(selector);

  const MODES = {
    laplace: {
      showB: false, showC: false, showOperator: false, operatorSymbol: '', resultLabel: '|A| Result',
      actionButton: 'animateLaplaceBtn', controlsId: 'laplaceControls', needsSquareA: true
    },
    multiply: {
      showB: true, showC: true, showOperator: true, operatorSymbol: '×', resultLabel: 'A × B',
      actionButton: 'animateMultiplyBtn', controlsId: 'multiplyControls', needsSquareA: false
    }
  };
  let currentMode = "laplace";
  const MIN_SIZE = 1, MAX_SIZE = 6; // Min size 1 for vectors/scalars in multiplication

  let matrixA = [];
  let matrixB = [];
  let matrixC = [];

  let animationTimeout = null;
  let skipAnimationFlag = false;

  // --- Matrix Utilities ---
  const Matrix = {
    create: (rows, cols, fillType = 'num', baseCharOrVal = 'a') => {
      const alpha = "abcdefghijklmnopqrstuvwxyz";
      let symIdx = 0;
      return Array.from({ length: rows }, (_, r) =>
        Array.from({ length: cols }, (_, c) => {
          if (fillType === 'num') return (Math.floor(Math.random() * 20) - 9).toString(); // -9 to 10
          if (fillType === 'sym') return baseCharOrVal + (++symIdx);
          if (fillType === 'zero') return '0';
          if (fillType === 'empty') return '';
          return "";
        })
      );
    },
    clone: m => m.map(r => r.slice()),
    isNumeric: m => m.flat().every(x => x !== '' && !isNaN(parseFloat(x))),
    parseNumeric: m => m.map(row => row.map(val => parseFloat(val))),

    randomize: (matRef, matrixName) => {
        const rows = matRef.length;
        const cols = matRef[0].length;
        const currentFlat = matRef.flat().join(',');
        const baseChar = matrixName === 'A' ? 'a' : (matrixName === 'B' ? String.fromCharCode('a'.charCodeAt(0) + rows * cols) : 'x');
        const type = rows * cols > 9 ? 'num' : 'sym'; // Heuristic for type

        let newMatrix;
        let attempts = 0;
        do {
            newMatrix = Matrix.create(rows, cols, type, baseChar);
            attempts++;
        } while (newMatrix.flat().join(',') === currentFlat && attempts < 20); // Try to get a different matrix
        return newMatrix;
    },

    determinant: (m) => {
      const numMatrix = Matrix.parseNumeric(m);
      const n = numMatrix.length;
      if (n === 0 || n !== numMatrix[0].length) return NaN; // Not square or empty

      if (n === 1) return numMatrix[0][0];
      if (n === 2) return numMatrix[0][0] * numMatrix[1][1] - numMatrix[0][1] * numMatrix[1][0];

      let det = 0;
      for (let j = 0; j < n; j++) {
        const minor = numMatrix.slice(1).map(row => row.filter((_, colIdx) => colIdx !== j));
        det += numMatrix[0][j] * Math.pow(-1, j) * Matrix.determinant(minor);
      }
      return det;
    },

    multiply: (mA, mB) => {
      if (!Matrix.isNumeric(mA) || !Matrix.isNumeric(mB)) return null; // only for numeric
      const numA = Matrix.parseNumeric(mA);
      const numB = Matrix.parseNumeric(mB);
      const rowsA = numA.length, colsA = numA[0].length, rowsB = numB.length, colsB = numB[0].length;
      if (colsA !== rowsB) return null; // Incompatible

      const result = Matrix.create(rowsA, colsB, 'zero');
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          let sum = 0;
          for (let k = 0; k < colsA; k++) {
            sum += numA[i][k] * numB[k][j];
          }
          result[i][j] = sum.toString();
        }
      }
      return result;
    }
  };

  // --- Rendering & UI ---
  function populateSelect(selectId, min, max, defaultValue) {
    const sel = qs(`#${selectId}`);
    sel.innerHTML = "";
    for (let i = min; i <= max; i++) {
      sel.innerHTML += `<option value="${i}"${i == defaultValue ? " selected" : ""}>${i}</option>`;
    }
  }

  function setupDimensionControls() {
    ['aRows', 'aCols', 'bCols'].forEach(id => {
        const isARowsOrCols = id === 'aRows' || id === 'aCols';
        const currentMatrix = id.startsWith('a') ? matrixA : matrixB;
        const defaultValue = (currentMatrix.length > 0 && id.includes('Rows')) ? currentMatrix.length :
                             (currentMatrix.length > 0 && currentMatrix[0].length > 0 && id.includes('Cols')) ? currentMatrix[0].length :
                             (id === 'aCols' || id === 'bCols' ? 3 : 3); // Default for initial load
        populateSelect(id, MIN_SIZE, MAX_SIZE, defaultValue);
    });
    qs('#bRows').innerHTML = `<option value="${qs('#aCols').value}">${qs('#aCols').value}</option>`; // bRows derived
  }


  function updateMatrixDimensions() {
    clearTimeout(animationTimeout);
    qs('#skipAnimBtn').style.display = 'none';

    const aRows = parseInt(qs('#aRows').value);
    const aCols = parseInt(qs('#aCols').value);
    const bColsVal = qs('#bCols').value; // Keep as string if not available
    const bCols = bColsVal ? parseInt(bColsVal) : aCols; // Default bCols if not set

    if (MODES[currentMode].needsSquareA && aRows !== aCols) {
        qs('#aCols').value = aRows; // Force square for Laplace
        // Potentially re-trigger update if we change aCols
        updateMatrixDimensions(); // Recursive call, be careful
        return;
    }
    
    const typeA = aRows * aCols > 9 ? 'num' : 'sym';
    matrixA = Matrix.create(aRows, aCols, typeA, 'a');

    if (MODES[currentMode].showB) {
      const bRows = aCols; // Matrix B rows must equal Matrix A columns
      qs('#bRows').innerHTML = `<option value="${bRows}">${bRows}</option>`;
      const typeB = bRows * bCols > 9 ? 'num' : 'sym';
      matrixB = Matrix.create(bRows, bCols, typeB, String.fromCharCode('a'.charCodeAt(0) + aRows*aCols));
    } else {
      matrixB = [];
    }

    if (MODES[currentMode].showC) {
      matrixC = Matrix.create(aRows, MODES[currentMode].showB ? bCols : aCols, 'empty');
    } else {
      matrixC = [];
    }
    renderUI();
  }

  function renderMatrix(tableId, matrix, highlightFn = () => "") {
    const table = qs(`#${tableId}`);
    if (!matrix || matrix.length === 0) {
      table.innerHTML = "";
      return;
    }
    table.innerHTML = matrix.map((row, i) =>
      `<tr>${row.map((val, j) =>
        `<td class="${highlightFn(i, j)}" onclick="editCell('${tableId}', ${i}, ${j})">${val}</td>`
      ).join('')}</tr>`
    ).join('');
  }

  function renderUI() {
    const modeConfig = MODES[currentMode];

    // Render matrices
    renderMatrix('mainMatrixA', matrixA);
    qs('#matrixBContainer').style.display = modeConfig.showB ? "" : "none";
    if (modeConfig.showB) renderMatrix('mainMatrixB', matrixB);

    qs('#operatorSymbol').style.display = modeConfig.showOperator ? "" : "none";
    qs('#operatorSymbol').textContent = modeConfig.operatorSymbol;

    qs('#equalsSymbol').style.display = modeConfig.showC ? "" : "none";
    qs('#matrixCContainer').style.display = modeConfig.showC ? "" : "none";
    qs('#resultMatrixLabel').textContent = modeConfig.resultLabel;
    if (modeConfig.showC) renderMatrix('mainMatrixC', matrixC);


    // Toggle controls visibility
    Object.values(MODES).forEach(mc => {
        qs(`#${mc.controlsId}`).style.display = mc.controlsId === modeConfig.controlsId ? "" : "none";
    });

    // Enable/Disable dimension selects
    qs('#aCols').disabled = modeConfig.needsSquareA;
    qs('#bCols').disabled = !modeConfig.showB;
    qs('#randomB').style.display = modeConfig.showB ? "" : "none";
    
    // Update action button text/state (can be more specific if needed)
    qs(`#${modeConfig.actionButton}`).disabled = (modeConfig.needsSquareA && matrixA.length !== matrixA[0]?.length);


    qs('#stepLatex').innerHTML = "";
    qs('#finalResultLatex').innerHTML = "";
    qs('#skipAnimBtn').style.display = "none";
    clearTimeout(animationTimeout); // Clear any pending animation
  }

  window.editCell = (tableId, r, c) => {
    let targetMatrix;
    if (tableId === 'mainMatrixA') targetMatrix = matrixA;
    else if (tableId === 'mainMatrixB') targetMatrix = matrixB;
    else targetMatrix = matrixC; // Should not happen for C if it's a result display

    const currentValue = targetMatrix[r][c];
    const newValue = prompt(`Enter value for cell (${r+1},${c+1}):`, currentValue);
    if (newValue !== null && newValue.trim() !== currentValue) {
      targetMatrix[r][c] = newValue.trim() === '' ? '0' : newValue.trim(); // Default to '0' if cleared
      renderUI(); // Re-render all for simplicity
      // If numeric, might want to check compatibility or update result immediately
      if (currentMode === 'multiply' && Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB) && matrixA[0].length === matrixB.length) {
          matrixC = Matrix.multiply(matrixA, matrixB);
          renderMatrix('mainMatrixC', matrixC);
      } else if (currentMode === 'laplace' && Matrix.isNumeric(matrixA) && matrixA.length === matrixA[0]?.length) {
          const det = Matrix.determinant(matrixA);
          qs('#finalResultLatex').innerHTML = `$$|A| = ${det}$$`;
          renderMathInElement(qs('#finalResultLatex'));
      }
    }
  };

  function switchMode(newMode) {
    currentMode = newMode;
    setupDimensionControls(); // Re-setup selects for default sizes of the mode
    updateMatrixDimensions(); // This will call renderUI
  }

  function randomizeMatrix(matrixIdentifier) { // 'A' or 'B'
    if (matrixIdentifier === 'A') {
      matrixA = Matrix.randomize(matrixA, 'A');
    } else if (matrixIdentifier === 'B' && matrixB.length > 0) {
      matrixB = Matrix.randomize(matrixB, 'B');
    }
    renderUI();
     // If numeric, might want to check compatibility or update result immediately
    if (currentMode === 'multiply' && Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB) && matrixA[0].length === matrixB.length) {
        matrixC = Matrix.multiply(matrixA, matrixB);
        renderMatrix('mainMatrixC', matrixC);
    } else if (currentMode === 'laplace' && Matrix.isNumeric(matrixA) && matrixA.length === matrixA[0]?.length) {
        const det = Matrix.determinant(matrixA);
        qs('#finalResultLatex').innerHTML = `$$|A| = ${det}$$`;
        renderMathInElement(qs('#finalResultLatex'));
    }
  }

  // --- Animation Logic ---
  function startLaplaceExpansion() {
    if (matrixA.length === 0 || matrixA.length !== matrixA[0]?.length) {
      qs('#stepLatex').innerHTML = "<div class='fade-in'><b>Error: Matrix A must be square for determinant.</b></div>";
      return;
    }
    clearTimeout(animationTimeout);
    skipAnimationFlag = false;
    qs('#skipAnimBtn').style.display = "inline-block";
    qs('#stepLatex').innerHTML = "";
    qs('#finalResultLatex').innerHTML = "";

    const n = matrixA.length;
    let currentStep = 0;
    const isNumeric = Matrix.isNumeric(matrixA);
    const originalMatrixLatex = `|A| = \\left|\\begin{array}{${"c".repeat(n)}}${matrixA.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right|`;
    qs('#finalResultLatex').innerHTML = `$$${originalMatrixLatex}$$`;
    renderMathInElement(qs('#finalResultLatex'));


    function animateNextLaplaceStep() {
      if (skipAnimationFlag) {
        currentStep = n; // Skip to end
      }

      if (currentStep < n) {
        // Highlight pivot and minor
        renderMatrix('mainMatrixA', matrixA, (r, c) => {
          if (r === 0 && c === currentStep) return 'selected'; // Pivot
          if (r > 0 && c !== currentStep) return 'minor'; // Part of minor
          return '';
        });

        const pivot = matrixA[0][currentStep];
        const sign = (currentStep % 2 === 0) ? "+" : "-";
        const minorMatrix = matrixA.slice(1).map(row => row.filter((_, colIdx) => colIdx !== currentStep));
        const minorLatex = `\\left|\\begin{array}{${"c".repeat(n-1)}}${minorMatrix.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right|`;
        
        let stepHtml = qs('#stepLatex').innerHTML;
        if (currentStep > 0) stepHtml += ` ${sign} `; else if (sign === "-") stepHtml += `${sign}`;
        stepHtml += `${pivot} \\cdot ${minorLatex}`;

        qs('#stepLatex').innerHTML = `<div class="fade-in">$$ ${originalMatrixLatex} = ${stepHtml} ... $$</div>`;
        renderMathInElement(qs('#stepLatex'));

        currentStep++;
        animationTimeout = setTimeout(animateNextLaplaceStep, skipAnimationFlag ? 1 : 1800);
      } else { // Animation finished or skipped
        renderMatrix('mainMatrixA', matrixA); // Clear highlights

        let finalExpansionLatex = "";
        for (let j = 0; j < n; j++) {
          const pivot = matrixA[0][j];
          const sign = (j % 2 === 0) ? (j > 0 ? "+" : "") : "-";
          const minorMatrix = matrixA.slice(1).map(row => row.filter((_, colIdx) => colIdx !== j));
          const minorLatex = n === 1 ? '1' : (n === 2 ? minorMatrix[0][0] : `\\left|\\begin{array}{${"c".repeat(n-1)}}${minorMatrix.map(row => row.join(" & ")).join("\\\\")}\\end{array}\\right|`);
          finalExpansionLatex += `${sign} ${pivot} \\cdot ${minorLatex} `;
        }

        let resultValue = "";
        if (isNumeric) {
          resultValue = ` = ${Matrix.determinant(matrixA)}`;
        }

        qs('#stepLatex').innerHTML = `<div class="fade-in">$$ ${originalMatrixLatex} = ${finalExpansionLatex} ${resultValue} $$</div>`;
        renderMathInElement(qs('#stepLatex'));
        qs('#skipAnimBtn').style.display = "none";
      }
    }
    animateNextLaplaceStep();
  }

  function startMatrixMultiplication() {
    if (matrixA.length === 0 || matrixB.length === 0 || matrixA[0].length !== matrixB.length) {
      qs('#stepLatex').innerHTML = "<div class='fade-in'><b>Error: Incompatible dimensions for multiplication. Columns of A must equal Rows of B.</b></div>";
      return;
    }
    clearTimeout(animationTimeout);
    skipAnimationFlag = false;
    qs('#skipAnimBtn').style.display = "inline-block";
    qs('#stepLatex').innerHTML = "";
    qs('#finalResultLatex').innerHTML = "";

    const rowsA = matrixA.length;
    const colsA = matrixA[0].length; // = rowsB
    const colsB = matrixB[0].length;
    matrixC = Matrix.create(rowsA, colsB, 'empty');
    renderMatrix('mainMatrixC', matrixC);

    let animState = { rA: 0, cB: 0, k: 0, currentSumLatex: "" }; // rA: row in A, cB: col in B, k: common index

    function animateNextMultiplyStep() {
      if (skipAnimationFlag) {
        matrixC = Matrix.multiply(matrixA, matrixB) || Matrix.create(rowsA, colsB, 'empty'); // Fallback for non-numeric
        renderMatrix('mainMatrixC', matrixC);
        qs('#stepLatex').innerHTML = "<div class='fade-in'><b>Multiplication Complete (Skipped)</b></div>";
        if (Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB)) {
             qs('#finalResultLatex').innerHTML = `$$ C = \\begin{pmatrix} ${matrixC.map(row => row.join(' & ')).join('\\\\ ')} \\end{pmatrix} $$`;
             renderMathInElement(qs('#finalResultLatex'));
        }
        qs('#skipAnimBtn').style.display = "none";
        return;
      }

      const { rA, cB, k } = animState;

      // Highlight relevant parts
      renderMatrix('mainMatrixA', matrixA, (r, c) => (r === rA && c === k) ? 'term-highlight' : (r === rA ? 'mul-row' : ''));
      renderMatrix('mainMatrixB', matrixB, (r, c) => (r === k && c === cB) ? 'term-highlight' : (c === cB ? 'mul-col' : ''));
      renderMatrix('mainMatrixC', matrixC, (r, c) => (r === rA && c === cB) ? 'mul-cell' : '');

      const valA = matrixA[rA][k];
      const valB = matrixB[k][cB];
      const term = (!isNaN(parseFloat(valA)) && !isNaN(parseFloat(valB))) ? (parseFloat(valA) * parseFloat(valB)).toString() : `(${valA}) \\cdot (${valB})`;
      
      if (k === 0) animState.currentSumLatex = ""; // Reset sum for new C_ij
      animState.currentSumLatex += (k > 0 ? " + " : "") + term;

      qs('#stepLatex').innerHTML = `<div class="fade-in">$$ c_{${rA+1}${cB+1}} = ${animState.currentSumLatex} $$</div>`;
      renderMathInElement(qs('#stepLatex'));

      // Update state for next step
      if (k < colsA - 1) {
        animState.k++;
      } else { // Element C_ij calculation finished
        let cellValue = 0;
        let isNumericCalculation = true;
        for(let sumIdx = 0; sumIdx < colsA; sumIdx++){
            const numA = parseFloat(matrixA[rA][sumIdx]);
            const numB = parseFloat(matrixB[sumIdx][cB]);
            if(isNaN(numA) || isNaN(numB)){
                isNumericCalculation = false;
                break;
            }
            cellValue += numA * numB;
        }
        matrixC[rA][cB] = isNumericCalculation ? cellValue.toString() : animState.currentSumLatex.replace(/\s/g,''); // Store simplified symbolic or numeric
        renderMatrix('mainMatrixC', matrixC, (r, c) => (r === rA && c === cB) ? 'mul-cell' : ''); // Update only result cell for now
        
        animState.k = 0;
        if (cB < colsB - 1) {
          animState.cB++;
        } else {
          animState.cB = 0;
          if (rA < rowsA - 1) {
            animState.rA++;
          } else { // All done
            renderMatrix('mainMatrixA', matrixA); // Clear A highlights
            renderMatrix('mainMatrixB', matrixB); // Clear B highlights
            qs('#stepLatex').innerHTML += "<div class='fade-in'><b>Multiplication Complete!</b></div>";
            if (Matrix.isNumeric(matrixA) && Matrix.isNumeric(matrixB)) { // Ensure final C is numeric if inputs were
                matrixC = Matrix.multiply(matrixA, matrixB);
                renderMatrix('mainMatrixC', matrixC); // re-render C with precise numeric results
                qs('#finalResultLatex').innerHTML = `$$ C = \\begin{pmatrix} ${matrixC.map(row => row.join(' & ')).join('\\\\ ')} \\end{pmatrix} $$`;
                renderMathInElement(qs('#finalResultLatex'));
            }
            qs('#skipAnimBtn').style.display = "none";
            return; // End animation
          }
        }
      }
      animationTimeout = setTimeout(animateNextMultiplyStep, skipAnimationFlag ? 1 : 1200);
    }
    animateNextMultiplyStep();
  }


  // --- Initialization ---
  document.addEventListener('DOMContentLoaded', () => {
    // Mode Buttons
    qs('#modeLaplaceBtn').addEventListener('click', () => switchMode('laplace'));
    qs('#modeMultiplyBtn').addEventListener('click', () => switchMode('multiply'));

    // Dimension Selects
    qsa('#aRows, #aCols, #bCols').forEach(sel => sel.addEventListener('change', updateMatrixDimensions));
    qs('#aCols').addEventListener('change', () => { // Special handling for aCols affecting bRows
        const مجلسValue = qs('#aCols').value;
        qs('#bRows').innerHTML = `<option value="${مجلسValue}">${مجلسValue}</option>`;
        if(currentMode === "multiply") updateMatrixDimensions(); // only update if in multiply mode
    });


    // Action Buttons
    qs('#animateLaplaceBtn').addEventListener('click', startLaplaceExpansion);
    qs('#animateMultiplyBtn').addEventListener('click', startMatrixMultiplication);
    qs('#skipAnimBtn').addEventListener('click', () => {
        skipAnimationFlag = true;
        // The animation loops will pick this up and fast-forward.
        // For multiply, it directly calculates. For Laplace, it finishes current step then jumps.
    });

    // Randomize Buttons
    qs('#randomA').addEventListener('click', () => randomizeMatrix('A'));
    qs('#randomB').addEventListener('click', () => randomizeMatrix('B'));
    
    // Initial Setup
    switchMode('laplace'); // Start in Laplace mode
    // updateMatrixDimensions called by switchMode
  });

  // --- Feature Test --- (Largely unchanged, minor adaptations might be needed if test logic broke)
  qs('#runFeatureTestBtn').onclick = function runFeatureTest() {
    (function(){
      let testLogEl = qs('#_featureTestLog');
      if (testLogEl) testLogEl.remove(); // Clear previous log

      function log(msg, pass) {
        let el = qs('#_featureTestLog');
        if (!el) {
          el = document.createElement('div');
          el.id = '_featureTestLog';
          el.style.cssText = 'position:fixed;bottom:8px;left:8px;background:#151b23;color:#ffe165;padding:1em 1.4em;border-radius:11px;font-size:0.9em;z-index:10000;max-width:450px;max-height:300px;overflow-y:auto;box-shadow:0 2px 16px #000a;';
          el.innerHTML = '<b>Feature Test Results</b><br>';
          document.body.appendChild(el);
        }
        el.innerHTML += `<div style="margin-top:4px;border-bottom:1px solid #333842;padding-bottom:3px;"><b style="color:${pass ? '#8fe388':'#ff8d8d'}">${pass?'✔':'✖'}</b> <span>${msg}</span></div>`;
        el.scrollTop = el.scrollHeight;
      }

      function getTableData(tableId, asNumber = true) {
        let mat = [], trs = qs(`#${tableId}`)?.querySelectorAll('tr');
        if (!trs) return [];
        for (let tr of trs) {
          let row = [];
          for (let td of tr.querySelectorAll('td')) row.push(asNumber ? Number(td.textContent) : td.textContent);
          mat.push(row);
        }
        return mat;
      }

      async function testAllCellEdits(matrixId, vals) {
        let table = qs(`#${matrixId}`), trs = table.querySelectorAll('tr'), pass = true;
        const originalPrompt = window.prompt;
        for(let i=0; i<vals.length; ++i) {
            for(let j=0; j<vals[0].length; ++j) {
                let td = trs[i].querySelectorAll('td')[j];
                window.prompt = () => String(vals[i][j]);
                td.click(); // This triggers editCell which calls prompt
                if(td.textContent !== String(vals[i][j])) pass = false;
            }
        }
        window.prompt = originalPrompt; // Restore original prompt

        await new Promise(resolve => setTimeout(resolve, 150)); // Wait for UI to settle from potential re-renders

        let finalTableData = getTableData(matrixId, false);
        let allMatch = vals.every((row, i) => row.every((val, j) => String(val) === finalTableData[i][j]));
        log(`All cells in "${matrixId}" editable and update correctly to ${JSON.stringify(vals)}`, allMatch);
        return allMatch;
      }

      async function testLaplaceExpansion() {
        log('--- Testing Laplace Expansion ---', true);
        qs('#modeLaplaceBtn').click();
        await new Promise(resolve => setTimeout(resolve, 100));

        qs('#aRows').value = 3; qs('#aCols').value = 3;
        qs('#aRows').dispatchEvent(new Event('change')); // Triggers updateMatrixDimensions
        await new Promise(resolve => setTimeout(resolve, 100));

        const testMatrixA = [[1,2,3],[0,4,5],[1,0,6]];
        await testAllCellEdits('mainMatrixA', testMatrixA);
        
        qs('#animateLaplaceBtn').click();
        await new Promise(resolve => setTimeout(resolve, 50)); // Animation starts
        qs('#skipAnimBtn').click(); // Skip it
        await new Promise(resolve => setTimeout(resolve, 300)); // Wait for skip completion

        const latexText = qs('#stepLatex').textContent;
        const expectedDeterminant = Matrix.determinant(testMatrixA.map(r=>r.map(String))); // Determinant function needs string matrix
        const passDet = latexText.includes(`= ${expectedDeterminant}`);
        log(`Laplace for [[1,2,3],[0,4,5],[1,0,6]] -> det = ${expectedDeterminant}`, passDet);
      }

      async function testMultiplicationMode() {
        log('--- Testing Matrix Multiplication ---', true);
        qs('#modeMultiplyBtn').click();
        await new Promise(resolve => setTimeout(resolve, 100));

        qs('#aRows').value = 2; qs('#aCols').value = 2; qs('#bCols').value = 2;
        qs('#aRows').dispatchEvent(new Event('change')); // This should also update bRows via aCols change
        await new Promise(resolve => setTimeout(resolve, 150));

        const testMatrixA_Mult = [[2,1],[0,1]];
        const testMatrixB_Mult = [[3,4],[1,2]];
        await testAllCellEdits('mainMatrixA', testMatrixA_Mult);
        await testAllCellEdits('mainMatrixB', testMatrixB_Mult);
        await new Promise(resolve => setTimeout(resolve, 100));

        // Test randomization (simple check: does it change?)
        const origA_data = getTableData('mainMatrixA', false).flat().join(',');
        qs('#randomA').click();
        await new Promise(resolve => setTimeout(resolve, 50));
        const newA_data = getTableData('mainMatrixA', false).flat().join(',');
        log('Randomize A changes matrix A', origA_data !== newA_data);
        // Restore for predictable multiplication test
        await testAllCellEdits('mainMatrixA', testMatrixA_Mult);


        qs('#animateMultiplyBtn').click();
        await new Promise(resolve => setTimeout(resolve, 50));
        qs('#skipAnimBtn').click();
        await new Promise(resolve => setTimeout(resolve, 300));

        const resultC_data = getTableData('mainMatrixC');
        const expectedC_data = [[7,10],[1,2]]; // (2*3+1*1), (2*4+1*2) | (0*3+1*1), (0*4+1*2)
        const passMult = JSON.stringify(resultC_data) === JSON.stringify(expectedC_data);
        log(`Multiply [[2,1],[0,1]] x [[3,4],[1,2]] = ${JSON.stringify(expectedC_data)}`, passMult);
      }
      
      async function runAllTests() {
        try {
            await testLaplaceExpansion();
            await new Promise(resolve => setTimeout(resolve, 300)); // Pause between major test groups
            await testMultiplicationMode();
            log('--- All Tests Completed ---', true);
        } catch (e) {
            log(`Testing Error: ${e.message}`, false);
            console.error("Test suite error:", e);
        }
      }
      setTimeout(runAllTests, 200); // Start tests after a brief pause
    })();
  };
</script>
</body>
</html>